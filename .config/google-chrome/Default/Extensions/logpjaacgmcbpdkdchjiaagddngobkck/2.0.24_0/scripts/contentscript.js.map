{"version":3,"sources":["scripts/contentscript.js"],"names":["Shortkeys","keys","fetchConfig","keyCombo","returnKey","length","forEach","key","doAction","keySetting","action","message","attribute","script","document","createElement","textContent","code","body","appendChild","removeChild","button","querySelector","click","chrome","runtime","sendMessage","activateKey","Mousetrap","bind","prototype","stopCallback","e","element","combo","classList","contains","activeInInputs","tagName","isContentEditable","url","URL","response"],"mappings":"AAAA,YAGA,IAAIA,aACJA,WAAUC,QAOVD,UAAUE,YAAc,SAAUC,GAC9B,GAAIC,IAAY,CAQhB,OAPIJ,WAAUC,KAAKI,OAAS,GACxBL,UAAUC,KAAKK,QAAQ,SAAUC,GACzBA,EAAIA,MAAQJ,IACZC,EAAYG,KAIjBH,GASXJ,UAAUQ,SAAW,SAAUC,GAC3B,GAAIC,GAASD,EAAWC,OACpBC,IACJ,KAAK,GAAIC,KAAaH,GAClBE,EAAQC,GAAaH,EAAWG,EAKpC,IAAe,eAAXF,EAAyB,CACzB,GAAIG,GAASC,SAASC,cAAc,SAIpC,OAHAF,GAAOG,YAAcP,EAAWQ,KAChCH,SAASI,KAAKC,YAAYN,OAC1BC,UAASI,KAAKE,YAAYP,GAIf,kBAAXH,IACID,EAAWY,QACXP,SAASQ,cAAcb,EAAWY,QAAQE,QAE9CZ,EAAQD,OAAS,WAGrBc,OAAOC,QAAQC,YAAYf,IAS/BX,UAAU2B,YAAc,SAAUlB,GAC9B,GAAIC,GAAS,WAET,MADAV,WAAUQ,SAASC,IACZ,EAEXmB,WAAUC,KAAKpB,EAAWF,IAAKG,IAYnCkB,UAAUE,UAAUC,aAAe,SAAUC,EAAGC,EAASC,GACrD,GAAIzB,GAAaT,UAAUE,YAAYgC,EAEvC,SAAID,EAAQE,UAAUC,SAAS,eAOnB3B,EAAW4B,iBAGQ,UAApBJ,EAAQK,SAA2C,WAApBL,EAAQK,SAA4C,aAApBL,EAAQK,SAA0BL,EAAQM,oBAWxHf,OAAOC,QAAQC,aAAchB,OAAQ,UAAW8B,IAAK1B,SAAS2B,KAAO,SAAUC,GACvEA,IACA1C,UAAUC,KAAOyC,EACb1C,UAAUC,KAAKI,OAAS,GACxBL,UAAUC,KAAKK,QAAQ,SAAUC,GAC7BP,UAAU2B,YAAYpB","file":"scripts/contentscript.js","sourcesContent":["'use strict';\n/* global Mousetrap */\n\nvar Shortkeys = {};\nShortkeys.keys = [];\n\n/**\n * Helper function for fetching the full key shortcut config given a keyboard combo.\n *\n * @param keyCombo\n */\nShortkeys.fetchConfig = function (keyCombo) {\n    var returnKey = false;\n    if (Shortkeys.keys.length > 0) {\n        Shortkeys.keys.forEach(function (key) {\n            if (key.key === keyCombo) {\n                returnKey = key;\n            }\n        });\n    }\n    return returnKey;\n};\n\n/**\n * Given a key shortcut config item, carry out the action configured for it.\n * This is what happens when the user triggers the shortcut.\n *\n * @param keySetting\n */\nShortkeys.doAction = function (keySetting) {\n    var action = keySetting.action;\n    var message = {};\n    for (var attribute in keySetting) {\n        message[attribute] = keySetting[attribute];\n    }\n\n    // It's a little hacky, but we have to insert JS this way rather than using executeScript() from the background JS,\n    // because this way we have access to the libraries that exist on the page on any given site, such as jQuery.\n    if (action === 'javascript') {\n        var script = document.createElement('script');\n        script.textContent = keySetting.code;\n        document.body.appendChild(script);\n        document.body.removeChild(script);\n        return;\n    }\n\n    if (action === 'buttonnexttab') {\n        if (keySetting.button) {\n            document.querySelector(keySetting.button).click();\n        }\n        message.action = 'nexttab';\n    }\n\n    chrome.runtime.sendMessage(message);\n};\n\n/**\n * Given a key shortcut config item, ask if the current site is allowed, and if so,\n * activate the shortcut.\n *\n * @param keySetting\n */\nShortkeys.activateKey = function (keySetting) {\n    var action = function action() {\n        Shortkeys.doAction(keySetting);\n        return false;\n    };\n    Mousetrap.bind(keySetting.key, action);\n};\n\n/**\n * Overrides the default stopCallback from Mousetrap so that we can customize\n * a few things, such as not using the \"whitelist inputs with the mousetrap class\"\n * functionality and wire up the \"activate in form inputs\" checkbox.\n *\n * @param e\n * @param element\n * @param combo\n */\nMousetrap.prototype.stopCallback = function (e, element, combo) {\n    var keySetting = Shortkeys.fetchConfig(combo);\n\n    if (element.classList.contains('mousetrap')) {\n        // We're not using the 'mousetrap' class functionality, which allows\n        // you to whitelist elements, so if we come across elements with that class\n        // then we can assume that they are provided by the site itself, not by\n        // us, so we don't activate Shortkeys in that case, to prevent conflicts.\n        // This fixes the chat box in Twitch.tv for example.\n        return true;\n    } else if (!keySetting.activeInInputs) {\n        // If the user has not checked \"Also allow in form inputs\" for this shortcut,\n        // then we cut out of the user is in a form input.\n        return element.tagName === 'INPUT' || element.tagName === 'SELECT' || element.tagName === 'TEXTAREA' || element.isContentEditable;\n    } else {\n        // The user HAS checked \"Also allow in form inputs\" for this shortcut so we\n        // have no reason to stop it from triggering.\n        return false;\n    }\n};\n\n/**\n * Fetches the Shortkeys configuration object and wires up each configured shortcut.\n */\nchrome.runtime.sendMessage({ action: 'getKeys', url: document.URL }, function (response) {\n    if (response) {\n        Shortkeys.keys = response;\n        if (Shortkeys.keys.length > 0) {\n            Shortkeys.keys.forEach(function (key) {\n                Shortkeys.activateKey(key);\n            });\n        }\n    }\n});"],"sourceRoot":"/source/"}